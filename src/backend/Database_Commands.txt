//Constructors:

//Schema:
CREATE SCHEMA IF NOT EXISTS "DBproject" AUTHORIZATION postgres;

//Tables:
CREATE TABLE IF NOT EXISTS "DBproject"."Chaine" ( nom_chaine character varying COLLATE pg_catalog."default" NOT NULL, adresse character varying COLLATE pg_catalog."default", nombre_hotels integer, hotel_emails character varying COLLATE pg_catalog."default", hotel_phones character varying COLLATE pg_catalog."default", CONSTRAINT "Chaine_pkey" PRIMARY KEY (nom_chaine) ) TABLESPACE pg_default;
ALTER TABLE IF EXISTS "DBproject"."Chaine" OWNER to postgres;

CREATE TABLE IF NOT EXISTS "DBproject"."Hotel" ( adresse character varying COLLATE pg_catalog."default", nombre_chambres integer, email character varying COLLATE pg_catalog."default", telephone integer, "ID_hotel" character(6) COLLATE pg_catalog."default" NOT NULL, nom_chaine character varying COLLATE pg_catalog."default", classe integer, CONSTRAINT "ID_hotel" PRIMARY KEY ("ID_hotel"), CONSTRAINT nom_chaine FOREIGN KEY (nom_chaine) REFERENCES "DBproject"."Chaine" (nom_chaine) MATCH SIMPLE ON UPDATE NO ACTION ON DELETE NO ACTION NOT VALID ) TABLESPACE pg_default;
ALTER TABLE IF EXISTS "DBproject"."Hotel" OWNER to postgres;

CREATE TABLE IF NOT EXISTS "DBproject"."Chambre" ( "ID_chambre" character(12) COLLATE pg_catalog."default" NOT NULL, prix integer, "commodités" character varying COLLATE pg_catalog."default", "capacité" character varying COLLATE pg_catalog."default", vue character varying COLLATE pg_catalog."default", peut_etendre boolean, dommages character varying COLLATE pg_catalog."default", "ID_hotel" character(6) COLLATE pg_catalog."default", CONSTRAINT "Chambre_pkey" PRIMARY KEY ("ID_chambre") ) TABLESPACE pg_default;
ALTER TABLE IF EXISTS "DBproject"."Chambre" OWNER to postgres;

CREATE TABLE IF NOT EXISTS "DBproject"."Employé" ( "NAS_employé" character(9) COLLATE pg_catalog."default" NOT NULL, nom_complet character varying COLLATE pg_catalog."default", "adresse " character varying COLLATE pg_catalog."default", role character varying COLLATE pg_catalog."default", CONSTRAINT "Employé_pkey" PRIMARY KEY ("NAS_employé") ) TABLESPACE pg_default;
ALTER TABLE IF EXISTS "DBproject"."Employé" OWNER to postgres;

CREATE TABLE IF NOT EXISTS "DBproject"."Client" ( "NAS_client" character(9) COLLATE pg_catalog."default" NOT NULL, nom_complet character varying COLLATE pg_catalog."default", "date_enregistré" date, adresse character varying COLLATE pg_catalog."default", CONSTRAINT "Client_pkey" PRIMARY KEY ("NAS_client") ) TABLESPACE pg_default;
ALTER TABLE IF EXISTS "DBproject"."Client" OWNER to postgres;

CREATE TABLE IF NOT EXISTS "DBproject"."Reservation" ( "ID_chambre" character(12) COLLATE pg_catalog."default", date_start date, date_end date, "NAS_client" character(9) COLLATE pg_catalog."default", status_paiement boolean, "ID_reservation" character varying COLLATE pg_catalog."default" NOT NULL, CONSTRAINT "Reservation_pkey" PRIMARY KEY ("ID_reservation"), CONSTRAINT "ID_chambre" FOREIGN KEY ("ID_chambre") REFERENCES "DBproject"."Chambre" ("ID_chambre") MATCH SIMPLE ON UPDATE NO ACTION ON DELETE NO ACTION NOT VALID, CONSTRAINT "NAS_client" FOREIGN KEY ("NAS_client") REFERENCES "DBproject"."Client" ("NAS_client") MATCH SIMPLE ON UPDATE NO ACTION ON DELETE NO ACTION NOT VALID ) TABLESPACE pg_default;
ALTER TABLE IF EXISTS "DBproject"."Reservation" OWNER to postgres;

CREATE TABLE IF NOT EXISTS "DBproject"."Location" ( "ID_reservation" character varying COLLATE pg_catalog."default", "NAS_employé" character(9) COLLATE pg_catalog."default", "NAS_client" character(9) COLLATE pg_catalog."default", "ID_chambre" character(12) COLLATE pg_catalog."default", date_start date, date_end date, "ID_Location" character varying COLLATE pg_catalog."default" NOT NULL, CONSTRAINT "Location_pkey" PRIMARY KEY ("ID_Location"), CONSTRAINT "ID_chambre" FOREIGN KEY ("ID_chambre") REFERENCES "DBproject"."Chambre" ("ID_chambre") MATCH SIMPLE ON UPDATE NO ACTION ON DELETE NO ACTION NOT VALID, CONSTRAINT "NAS_client" FOREIGN KEY ("NAS_client") REFERENCES "DBproject"."Client" ("NAS_client") MATCH SIMPLE ON UPDATE NO ACTION ON DELETE NO ACTION NOT VALID, CONSTRAINT "NAS_employé" FOREIGN KEY ("NAS_employé") REFERENCES "DBproject"."Employé" ("NAS_employé") MATCH SIMPLE ON UPDATE NO ACTION ON DELETE NO ACTION NOT VALID, CONSTRAINT "ID_reservation" FOREIGN KEY ("ID_reservation") REFERENCES "DBproject"."Reservation" ("ID_reservation") MATCH SIMPLE ON UPDATE NO ACTION ON DELETE NO ACTION) TABLESPACE pg_default;
ALTER TABLE IF EXISTS "DBproject"."Location" OWNER to postgres;





//Triggers:
CREATE OR REPLACE FUNCTION "DBproject".sync_reservation_rentalf()
    RETURNS trigger
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE NOT LEAKPROOF
    AS $BODY$
BEGIN
    SELECT COUNT(ID_reservation) AS num FROM Reservation WHERE ID_reservation = NEW.ID_Reservation;
    IF num=0 THEN
        SELECT MAX(ID_Reservation) AS nextID FROM Reservation;
        INSERT INTO Reservation(ID_reservation, NAS_client, ID_chambre, Date_start, Date_end)
            VALUES(NEW.ID_reservation, NEW.NAS_client, NEW.ID_chambre, NEW.Date_start, NEW.Date_end);
    END IF;
END;
$BODY$;

ALTER FUNCTION "DBproject".sync_reservation_rentalf()
    OWNER TO postgres;

CREATE OR REPLACE TRIGGER sync_reservation_rental
    BEFORE INSERT
    ON "DBproject"."Location"
    FOR EACH ROW
    EXECUTE FUNCTION "DBproject".sync_reservation_rentalf();

CREATE OR REPLACE FUNCTION "DBproject".sync_reservation_rental_updatef()
    RETURNS trigger
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE NOT LEAKPROOF
    AS $BODY$
BEGIN
    UPDATE Reservation
       SET NAS_client=NEW.NAS_client, ID_chambre=NEW.ID_chambre, Date_start=NEW.Date_start, Date_end=NEW.Date_end
       WHERE NEW.ID_Reservation=ID_Reservation;
END;
$BODY$;

ALTER FUNCTION "DBproject".sync_reservation_rental_updatef()
    OWNER TO postgres;

CREATE OR REPLACE TRIGGER sync_reservation_rental_update
    BEFORE UPDATE
    ON "DBproject"."Location"
    FOR EACH ROW
    EXECUTE
    FUNCTION "DBproject".sync_reservation_rental_updatef();


//Indexes:
CREATE INDEX IF NOT EXISTS room_by_hotel
    ON "DBproject"."Chambre" USING hash
    ("ID_hotel" COLLATE pg_catalog."default")
    TABLESPACE pg_default;

CREATE INDEX IF NOT EXISTS rental_by_date
ON "DBproject"."Location" USING btree
(date_start ASC NULLS LAST,date_end ASC NULLS LAST)
TABLESPACE pg_default;

CREATE INDEX IF NOT EXISTS rental_by_room
ON "DBproject"."Location" USING hash
    ("ID_chambre" COLLATE pg_catalog."default")
    TABLESPACE pg_default;

CREATE INDEX IF NOT EXISTS rental_by_reservation
ON "DBproject"."Location" USING hash
    ("ID_reservation" COLLATE pg_catalog."default")
    TABLESPACE pg_default;

CREATE INDEX IF NOT EXISTS  reservation_by_date
ON "DBproject"."Reservation" USING btree
(date_start ASC NULLS LAST,date_end ASC NULLS LAST)
TABLESPACE pg_default;

CREATE INDEX IF NOT EXISTS reservation_by_room
ON "DBproject"."Reservation" USING hash
    ("ID_chambre" COLLATE pg_catalog."default")
    TABLESPACE pg_default;

CREATE INDEX IF NOT EXISTS hotel_by_address
ON "DBproject"."Hotel" USING hash
    ("adresse" COLLATE pg_catalog."default")
    TABLESPACE pg_default;


//views:
CREATE OR REPLACE VIEW "DBproject".numOfRoomsByZone AS
    SELECT count("Hotel".nombre_chambres)
    FROM "DBproject"."Hotel"
    WHERE "Hotel".adresse::text ~~ '%cityname%'::text;





break;
Commands to run to update backend.Database:


break;

